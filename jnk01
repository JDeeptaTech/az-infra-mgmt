pipeline {
    agent any

    // Define the Parameter Dropdown
    parameters {
        choice(
            name: 'MANUAL_ENV_SELECT', 
            choices: ['Auto-Detect', 'hic-poc', 'hic-sap', 'hic-dev', 'uat', 'prod'], 
            description: 'Select Environment (Only used if not triggered by Git Push)'
        )
    }

    environment {
        // --- CONFIGURATION ---
        GIT_CREDENTIAL_ID = 'git-api-token'
        REPO_OWNER = 'your-org'
        REPO_NAME = 'your-repo'
        ALLURE_RESULTS_DIR = 'allure-results'
        BASE_VERSION = "1.0"
    }

    stages {
        stage('Initialize & Calculate Promotion') {
            steps {
                script {
                    // --- 1. DEFINE THE MAP (From your image) ---
                    def branchToEnvMap = [
                        1 : [branch: 'poc-aap',    app_env: 'hic-poc'],
                        2 : [branch: 'sap-aap',    app_env: 'hic-sap'],
                        3 : [branch: 'dev-aap',    app_env: 'hic-dev'],
                        4 : [branch: 'uat-aap',    app_env: 'uat'],
                        5 : [branch: 'master-aap', app_env: 'prod']
                    ]

                    // --- 2. IDENTIFY CURRENT LEVEL ---
                    // We try to find the current branch in the map
                    def currentLevel = null
                    def currentEntry = null
                    
                    // Iterate to find matching branch
                    branchToEnvMap.each { key, value ->
                        if (value.branch == env.BRANCH_NAME) {
                            currentLevel = key
                            currentEntry = value
                        }
                    }

                    // Handle "Manual" selection or Feature Branches not in map
                    if (!currentLevel) {
                         echo "Branch ${env.BRANCH_NAME} is not in the official map."
                         // Fallback logic could go here, or we fail.
                         // For this example, we proceed only if it's a known branch.
                         currentLevel = 0 
                    }

                    if (currentLevel > 0) {
                        env.CURRENT_ENV = currentEntry.app_env
                        
                        // --- 3. CALCULATE NEXT LEVEL (PROMOTION) ---
                        def nextLevel = currentLevel + 1
                        
                        if (branchToEnvMap.containsKey(nextLevel)) {
                            def nextEntry = branchToEnvMap[nextLevel]
                            env.TARGET_BRANCH = nextEntry.branch
                            env.TARGET_ENV = nextEntry.app_env
                            echo "Current Level: ${currentLevel} (${env.CURRENT_ENV})"
                            echo "Next Promotion Target: ${nextLevel} (${env.TARGET_ENV}) on branch ${env.TARGET_BRANCH}"
                        } else {
                            env.TARGET_BRANCH = ""
                            echo "Current Level: ${currentLevel} is the Final Stage (Production). No promotion target."
                        }

                        // Set Tag Name using the App Env from map
                        env.TAG_NAME = "v${BASE_VERSION}.${env.BUILD_NUMBER}-${env.CURRENT_ENV}"
                        
                    } else {
                        error("This pipeline must be run on a valid branch defined in the map.")
                    }
                }
            }
        }

        stage('Create Tag & Pre-Release') {
            steps {
                script {
                    withCredentials([string(credentialsId: "$GIT_CREDENTIAL_ID", variable: 'GIT_TOKEN')]) {
                        // Check if tag exists (Re-run logic)
                        def tagExists = sh(script: "git ls-remote --tags origin ${TAG_NAME}", returnStdout: true).trim()

                        if (tagExists) {
                            echo "Tag ${TAG_NAME} exists. Reusing for rerun."
                        } else {
                            // Create Tag
                            sh """
                                git tag ${TAG_NAME}
                                git push origin ${TAG_NAME}
                            """
                            // Create Pre-Release
                            def payload = """
                            {
                              "tag_name": "${TAG_NAME}",
                              "target_commitish": "${env.BRANCH_NAME}",
                              "name": "${TAG_NAME}",
                              "body": "Environment: ${env.CURRENT_ENV}",
                              "draft": false,
                              "prerelease": true
                            }
                            """
                            sh """
                                curl -L -X POST \
                                -H "Authorization: Bearer ${GIT_TOKEN}" \
                                -H "Accept: application/vnd.github+json" \
                                https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases \
                                -d '${payload}'
                            """
                        }
                    }
                }
            }
        }

        stage('Run Tests') {
            steps {
                // Checkout and Test Logic (Same as previous)
                checkout([
                    $class: 'GitSCM', 
                    branches: [[name: "refs/tags/${TAG_NAME}"]], 
                    userRemoteConfigs: [[credentialsId: "$GIT_CREDENTIAL_ID", url: "https://github.com/${REPO_OWNER}/${REPO_NAME}.git"]]
                ])
                script {
                    try {
                        echo "Running tests for environment: ${env.CURRENT_ENV}"
                        // sh "pytest ..."
                    } catch (Exception e) {
                        currentBuild.result = 'FAILURE'
                        error("Tests Failed.")
                    }
                }
            }
        }

        stage('Promote & Create PR') {
            when {
                allOf {
                    expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
                    expression { env.TARGET_BRANCH != '' } // Only run if there is a next level
                }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: "$GIT_CREDENTIAL_ID", variable: 'GIT_TOKEN')]) {
                        echo "Promoting from ${env.BRANCH_NAME} to ${env.TARGET_BRANCH}"

                        // 1. Update Release to Latest/Stable
                        // (Retrieve ID logic here...)
                        // (Patch Release logic here...)

                        // 2. Create Pull Request using the Map data
                        def prBody = """
                        {
                          "title": "Promote ${env.CURRENT_ENV} to ${env.TARGET_ENV}",
                          "body": "Automated Promotion.\\nFrom: ${env.BRANCH_NAME}\\nTo: ${env.TARGET_BRANCH}\\nTag: ${TAG_NAME}",
                          "head": "${env.BRANCH_NAME}",
                          "base": "${env.TARGET_BRANCH}"
                        }
                        """
                        
                        sh """
                            curl -L -X POST \
                            -H "Authorization: Bearer ${GIT_TOKEN}" \
                            -H "Accept: application/vnd.github+json" \
                            https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/pulls \
                            -d '${prBody}' || true
                        """
                    }
                }
            }
        }
    }
}
